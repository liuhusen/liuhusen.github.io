<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>藏书阁</title>
  <icon>https://www.gravatar.com/avatar/f891a51eb4e19375142db2543d2003e2</icon>
  <subtitle>奔跑</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liuhusen.com/"/>
  <updated>2019-04-02T03:33:26.078Z</updated>
  <id>https://liuhusen.com/</id>
  
  <author>
    <name>Mr.Liu</name>
    <email>I_striving@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql存储过程和oracle存储过程对比</title>
    <link href="https://liuhusen.com/2018/12/30/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8Coracle%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%AF%B9%E6%AF%94/"/>
    <id>https://liuhusen.com/2018/12/30/mysql存储过程和oracle存储过程对比/</id>
    <published>2018-12-29T18:01:30.000Z</published>
    <updated>2019-04-02T03:33:26.078Z</updated>
    
    <content type="html"><![CDATA[<pre><code>区别如下：       1      创建存储过程语句不同：           ORACLE：  create or replace procedure P_ADD_FAC(id_fac_cd  IN ES_FAC_UNIT.FAC_CD%TYPE) is               MYSQL：   DROP PROCEDURE IF EXISTS `SD_USER_P_ADD_USR`;create procedure P_ADD_FAC(id_fac_cd  varchar(100))                注释：1.在创建存储过程时如果存在同名的存储过程,会删除老的存储过程.                      oracle使用create or replace.                     mysql使用先删除老的存储过程,然后再创建新的存储过程.                  2. oracle 存储过程可以定义在package中,也可以定义在Procedures中. 如果定义在包中,                     一个包中可以包含多个存储过程和方法.如果定义在Procedures中,存储过程中不可以定义多个存储过程.                      Mysql  存储过程中不可以定义多个存储过程.                   3. oracle中字符串类型可以使用varchar2.                       Mysql 需要使用varchar                  4. Oracle中参数varchar长度不是必须的,                     Mysql中参数varchar长度是必须的, 比如varchar(100)       2    创建函数语句不同：            ORACLE： CREATE OR REPLACEFUNCTION F_ROLE_FACS_GRP(                       ii_role_int_key IN SD_ROLE.ROLE_INT_KEY%TYPE                      ) RETURN VARCHAR2               MYSQL： DROP FUNCTION IF EXISTS `SD_ROLE_F_ROLE_FACS_GRP`;                      CREATE  FUNCTION `SD_ROLE_F_ROLE_FACS_GRP`(                       ii_role_int_key INTEGER(10)                      ) RETURNS varchar(1000)               注释：        1.在创建函数时如果存在同名的函数,会删除老的函数.                          oracle使用create or replace.                        mysql使用先删除老的函数,然后再创建新的函数.                      2. oracle 函数可以定义在package中,也可以定义在Functions中. 如果定义在包中,一个包中可以包含多个存储过程和函数.如果定义在Functions中,每个函数只能定义一个函数.                         Mysql  Functions不可以定义多个函数.                       3.  oracle返回值用return.                           Mysql返回值用returns.       3    传入参数写法不同：           ORACLE：procedure P_ADD_FAC(                   id_fac_cd  IN ES_FAC_UNIT.FAC_CD%TYPE)               MYSQL： create procedure P_ADD_FAC(                   (in) id_fac_cd  varchar(100))              注释：    1. oracle存储过程参数可以定义为表的字段类型.                     Mysql存储过程不支持这种定义方法.需要定义变量的实际类型和长度.                  2. oracle 参数类型in/out/inout写在参数名后面.                      Mysql  参数类型in/out/inout写在参数名前面.                  3. oracle 参数类型in/out/inout 都必须写.                     Mysql  参数类型如果是in,则可以省略. 如果是out或inout则不能省略.                  注意: mysql中指定参数为IN, OUT, 或INOUT 只对PROCEDURE是合法的。（FUNCTION参数总是被认为是IN参数） RETURNS字句只能对FUNCTION做指定，对函数而言这是强制的。它用来指定函数的返回类型，而且函数体必须包含一个RETURN value语句。                    function func_name(                             gw_id  in(out)  varchar2 )    create function func_name(                         gw_id varchar（100))      4    包的声明方式：           ORACLE：create or replace package/package body package name               MYSQL： 拆分成多个存储过程或函数               注释： oracle可以创建包,包中可以包含多个存储过程和方法.                   mysql没有没有包这个概念,可以分别创建存储过程和方法. 每个存储过程或方法都需要放在一个文件中.                   例1: 方法命名                   oracle 中SD_FACILITY_PKG.F_SEARCH_FAC                   to mysql SD_FACILITY_F_SEARCH_FAC                   例2: 过程命名                  oracle 中SD_FACILITY_PKG.P_ADD_FAC                  to mysql SD_FACILITY_P_ADD_FAC       5    存储过程返回语句不一样：          ORACLE：return;              MYSQL： LEAVE proc; (proc 代表最外层的begin end)              注释：  oracle存储过程和方法都可以使用return退出当前过程和方法.                   Mysql存储过程中只能使用leave退出当前存储过程.不可以使用return.                   Mysql方法可以使用return退出当前方法.       6    存储过程异常处理不一样：          ORACLE：EXCEPTION                  WHEN OTHERS THEN                  ROLLBACK ;                  ov_rtn_msg := c_sp_name||&apos;(&apos;|| li_debug_pos ||&apos;):&apos;||                      TO_CHAR(SQLCODE)||&apos;: &apos;||SUBSTR(SQLERRM,1,100);              MYSQL：    DECLARE EXIT HANDLER FOR  SQLEXCEPTION                    BEGIN                      ROLLBACK ;                      set ov_rtn_msg = concat(c_sp_name,&apos;(&apos;, li_debug_pos ,&apos;):&apos;,                          TO_CHAR(SQLCODE),&apos;: &apos;,SUBSTR(SQLERRM,1,100));                   END;              注释： oracle : 内部异常不需要定义,在存储过程或函数末尾写上EXCEPTION后,后面的部分即为异常处理的部分.                            oracle可以定义自定义异常,自定义异常需要使用raise关键字抛出异常后,才可以在EXCEPTION中捕获.                  mysql: mysql内部异常也需要先定义,在定义的同时也需要实现异常的功能.                             目前mysql不支持自定义异常.       7    过程和函数的声明变量的位置不同：            ORACLE：声明变量在begin…end体之前              MYSQL：    声明变量在begin...end体内，begin之后其他任何内容之前    　      8    NO_DATA_FOUND异常处理：          ORACLE：EXCEPTION                  WHEN NO_DATA_FOUND THEN                      oi_rtn_cd := 1;                      ov_rtn_msg := SD_COMMON.P_GET_MSG(&apos;DP-CBM-01100a-016&apos;,                                                       li_sub_rtn_cd,                                                       lv_sub_rtn_msg);              MYSQL：    使用FOUND_ROWS()代替NO_DATA_FOUND.           注释：    oracle中:                           NO_DATA_FOUND是游标的一个属性.                           当select没有查到数据就会出现 no data found 的异常，程序不会向下执行.                  Mysql:                           没有NO_DATA_FOUND这个属性.但可是使用FOUND_ROWS()方法得到select语句查询出来的数据.                          如果FOUND_ROWS()得到的值为0,就进入异常处理逻辑.       9    在存储过程中调用存储过程方式的不同：          ORACLE：Procedure_Name(参数);              MYSQL：    Call Procedure_Name(参数);              注释：MYSQL存储过程调用存储过程，需要使用Call pro_name(参数).                  Oracle调用存储过程直接写存储过程名就可以了.       10    抛异常的方式不同：          ORACLE：RAISE Exception_Name;          MYSQL：    待续。。。。。。。。            </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;区别如下： 

      1      创建存储过程语句不同：

           ORACLE：  create or replace procedure P_ADD_FAC(id_fac_cd  IN ES_FAC_UNIT.FAC_CD%TYPE
      
    
    </summary>
    
      <category term="数据库" scheme="https://liuhusen.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="存储过程" scheme="https://liuhusen.com/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    
      <category term="数据库相关操作" scheme="https://liuhusen.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>mysql存储过程------其他相关操作</title>
    <link href="https://liuhusen.com/2018/12/09/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B------%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    <id>https://liuhusen.com/2018/12/09/mysql存储过程------其他相关操作/</id>
    <published>2018-12-09T02:03:30.000Z</published>
    <updated>2019-04-02T03:02:25.141Z</updated>
    
    <content type="html"><![CDATA[<pre><code>操作如下：           CREATE TABLE `tstudent4` (            `id` int(15) NOT NULL,            `Sname` varchar(32) DEFAULT NULL,            `sex` char(1) DEFAULT NULL,            `cardID` int(12) DEFAULT NULL,            `Birthday` date DEFAULT NULL,            `Email` varchar(40) DEFAULT NULL,            `Class` varchar(20) DEFAULT NULL,            `enterTime` datetime DEFAULT NULL,            `cmos_modify_time` datetime(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3) ON UPDATE CURRENT_TIMESTAMP(3),            PRIMARY KEY (`id`),            KEY `pri_stuid` (`id`),            KEY `idx_cmos_modify_time` (`cmos_modify_time`)          ) ENGINE=InnoDB DEFAULT CHARSET=utf8          ----------------------------------------------------------------------          DELIMITER $$          CREATE PROCEDURE `testStudent`( IN iCount INT)          BEGIN                  DECLARE i INT;                  DECLARE    inum INT;                  DECLARE    iid INT;                  start transaction;                  SET i =1;                  SELECT COUNT(0) INTO inum FROM tstudent4;                  IF inum &gt; 1                      THEN SELECT MAX(id) INTO inum FROM tstudent4;                  END IF;                  WHILE i &lt;= iCount DO                  INSERT tstudent4 VALUES (                      inum+i,                      CONCAT(&apos;李长青&apos;,inum+i),                      IF(CEIL(RAND()*10)%2=0,&apos;男&apos;,&apos;女&apos;),                      CEIL(RAND()*100000000),                      CONCAT(CONVERT(CEIL(RAND()*10)+1980,CHAR(4)),&apos;-&apos;,LPAD(CONVERT(CEIL(RAND()*12),                      CHAR(2)),2,&apos;0&apos;),&apos;-&apos;,LPAD(CONVERT(CEIL(RAND()*28),CHAR(2)),2,&apos;0&apos;)),                      CONCAT(CONCAT(&apos;lichangqing&apos;,inum+i),&apos;@hotmail.com&apos;),                      CASE CEIL(RAND()*3) WHEN 1 THEN &apos;网络与网站开发&apos; WHEN 2 THEN &apos;计算机科学技术&apos; ELSE &apos;性能巧匠训练营&apos; END,                      NOW(),CURRENT_TIMESTAMP(3));                  SET i = i + 1;                  END WHILE;                  commit;                  SET i =CEIL(RAND()*iCount);                  SELECT id INTO iid FROM tstudent4 ORDER BY RAND() LIMIT 1;                   UPDATE tstudent4 SET sname=CONCAT(&apos;张芳敏&apos;,id), cardID=CEIL(RAND()*100000000) WHERE id between iid and  iid+i;                  SET i =CEIL(RAND()*iCount);                  SELECT id INTO iid FROM tstudent4 ORDER BY RAND() LIMIT 1;                   delete from tstudent4 WHERE id between iid and  iid+i;              END$$          DELIMITER ;          ----------------------------清理2小时前的binlog日志--------------------------------------------、          DELIMITER $$          CREATE  PROCEDURE `clearlog`()          BEGIN                  PURGE MASTER LOGS BEFORE DATE_SUB(CURRENT_TIME, INTERVAL 2 HOUR);          END$$          DELIMITER ;          -----------------------------mysql相关设置开关--------------------------------------          SHOW VARIABLES LIKE &apos;event_scheduler&apos;          SET GLOBAL event_scheduler = 1;          SHOW VARIABLES LIKE &apos;autocommit&apos;          set session autocommit = 0;          --设置safe update模式          SHOW VARIABLES LIKE &apos;SQL_SAFE_UPDATES&apos;;          set SQL_SAFE_UPDATES = 1;          ----------------------------创建事务--------------------------------------------          CREATE  EVENT `example_event2`           ON SCHEDULE EVERY 10 SECOND STARTS CURRENT_TIMESTAMP           ON COMPLETION NOT PRESERVE ENABLE           DO call testStudent(100);          -------------------binlog相关--------------------------------------------------------          show global variables like &apos;gtid_%&apos;;     //查询gtid信息：          show global variables like &apos;server_uuid&apos;;  //查看机器uuid：          中断存储过程或者事务          show processlist；          kill  id          show binlog events in &apos;mysql-bin.000002&apos;;   //查看指定binlog文件的内容          show binary logs;  //获取binlog列表          show  master logs;  //查询日志          --------------------------------------DDL操作-----------------------------------------------          CREATE TABLE `testtab` (            `id` int(15) NOT NULL,            `Sname` varchar(10) DEFAULT NULL,            `sex` char(1) DEFAULT NULL,            `cardID` int(12) DEFAULT NULL,            `Birthday` date DEFAULT NULL,            `Email` varchar(40) DEFAULT NULL            ) ENGINE=InnoDB DEFAULT CHARSET=utf8;          插入列：          ALTER TABLE testtab ADD testdate DATETIME DEFAULT NOW();             更新列类型：          ALTER TABLE testtab MODIFY  testdate varchar(12) DEFAULT NULL COMMENT &apos;测试列更新&apos;;          更新列名：          ALTER TABLE testtab change  testdate changecol int(12);          删除列：          ALTER TABLE testtab DROP changecol;          创建主键：          alter table testtab add primary key(id);          全文索引：          CREATE  FULLTEXT INDEX IDX_KSD  ON  testtab (email);          普通索引：          CREATE   INDEX IDX_NAME  ON  testtab (sname);          唯一索引：          CREATE UNIQUE  INDEX IDX_STUNAME  ON  testtab (sname);          组合索引：          CREATE INDEX MultiIdx   ON testtab (id,sname);          主键索引：          CREATE   INDEX IDX_ID  ON  testtab (id);          BTREE索引：          CREATE   INDEX IDX_cardid USING BTREE  ON  testtab (cardID);          删除索引：          DROP INDEX  IDX_KSD  ON testtab ;          DROP INDEX  IDX_NAME  ON testtab ;          DROP INDEX  IDX_STUNAME  ON testtab ;          DROP INDEX  MultiIdx  ON testtab ;          DROP INDEX  IDX_ID  ON testtab ;          DROP INDEX  IDX_cardid  ON testtab ;          删除主键：          alter table testtab drop primary key;          重命名表：          rename table testtab to tsrenmtabl;          删除表：          DROP TABLE tsrenmtabl;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;操作如下： 
          CREATE TABLE `tstudent4` (
            `id` int(15) NOT NULL,
            `Sname` varchar(32) DEFAULT NULL,
    
      
    
    </summary>
    
      <category term="数据库" scheme="https://liuhusen.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="存储过程" scheme="https://liuhusen.com/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    
      <category term="数据库相关操作" scheme="https://liuhusen.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>mysql存储过程------批量建表删表</title>
    <link href="https://liuhusen.com/2018/12/08/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B------%E6%89%B9%E9%87%8F%E5%BB%BA%E8%A1%A8%E5%88%A0%E8%A1%A8/"/>
    <id>https://liuhusen.com/2018/12/08/mysql存储过程------批量建表删表/</id>
    <published>2018-12-08T05:01:30.000Z</published>
    <updated>2019-04-02T03:00:19.461Z</updated>
    
    <content type="html"><![CDATA[<pre><code>操作如下：       CREATE TABLE `tstudent4` (        `studentID` int(15) NOT NULL,        `Sname` varchar(64) DEFAULT NULL,        `sex` char(1) DEFAULT NULL,        `cardID` varchar(20) DEFAULT NULL,        `Birthday` date DEFAULT NULL,        `Email` varchar(40) DEFAULT NULL,        `Class` varchar(20) DEFAULT NULL,        `enterTime` datetime DEFAULT NULL,        `remarks` mediumtext,        `cmos_modify_time` datetime(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3) ON UPDATE CURRENT_TIMESTAMP(3),        PRIMARY KEY (`studentID`),        KEY `pri_stuid` (`studentID`),        KEY `idx_cmos_modify_time` (`cmos_modify_time`)      ) ENGINE=InnoDB DEFAULT CHARSET=utf8      ----------------------------------------------------------------------      DELIMITER $$      CREATE PROCEDURE `addStudent4`( IN iCount INT)      BEGIN              DECLARE i INT;              DECLARE    inum INT;              SET i =1;              SELECT COUNT(0) INTO inum FROM tstudent4;              IF inum &gt; 1                  THEN SELECT MAX(studentID) INTO inum FROM tstudent4;              END IF;              start transaction;              WHILE i &lt;= iCount DO              INSERT tstudent4 VALUES (                  inum+i,                  CONCAT(&apos;阿兰&apos;,inum+i),                  IF(CEIL(RAND()*10)%2=0,&apos;男&apos;,&apos;女&apos;),                  RPAD(CONVERT(CEIL(RAND()*1000000000000000000),CHAR(18)),18,&apos;0&apos;),                  CONCAT(CONVERT(CEIL(RAND()*10)+1980,CHAR(4)),&apos;-&apos;,LPAD(CONVERT(CEIL(RAND()*12),                  CHAR(2)),2,&apos;0&apos;),&apos;-&apos;,LPAD(CONVERT(CEIL(RAND()*28),CHAR(2)),2,&apos;0&apos;)),                  CONCAT(CONCAT(&apos;alan&apos;,inum+i),&apos;@hotmail.com&apos;),                  CASE CEIL(RAND()*3) WHEN 1 THEN &apos;网络与网站开发&apos; WHEN 2 THEN &apos;计算机科学技术&apos; ELSE &apos;汇编语言初入门&apos; END,                  NOW(),&apos;河南省郑州市金水区第一实验小学一年级一班&apos;,                  CURRENT_TIMESTAMP(3));              SET i = i + 1;              END WHILE;              commit;          END$$      DELIMITER ;      -------------------------------------------------------------------      DELIMITER $$      CREATE PROCEDURE `upStudent4`(IN iCount INT)      BEGIN              DECLARE    iid INT;              DECLARE    i INT;              SET i =CEIL(RAND()*iCount)+100;              SELECT studentID INTO iid FROM tstudent4 ORDER BY RAND() LIMIT 1;               UPDATE tstudent4 SET cardID=RPAD(CONVERT(CEIL(RAND()*1000000000000000000),CHAR(18)),18,&apos;0&apos;) WHERE studentID between iid and  iid+i;          END$$      DELIMITER ;      -----------------------------------------------------------------------      DELIMITER $$      CREATE  PROCEDURE `teststudent4`()      BEGIN              DECLARE    iid INT;              DECLARE    i INT;              SET i =CEIL(RAND()*200)+100;              CALL `addStudent4`(5000);              CALL `upStudent4`(200);              SELECT min(studentID) INTO iid FROM tstudent4;              DELETE FROM  tstudent4 WHERE studentID between iid and  iid+i;          END$$      DELIMITER ;      ------------------------------------------------------------------------      CREATE  EVENT `example_event2`       ON SCHEDULE EVERY 10 SECOND STARTS CURRENT_TIMESTAMP       ON COMPLETION NOT PRESERVE ENABLE       DO call teststudent4();      ---------------批量建表----------------------------------      DELIMITER $$      CREATE  PROCEDURE `createTables`( IN table_pre VARCHAR(20),IN iCount INT)      BEGIN              DECLARE i INT;              DECLARE table_name VARCHAR(20);                DECLARE sql_text VARCHAR(2000);               SET i=0;              SET table_name=&apos;&apos;;              SET sql_text=&apos;&apos;;              WHILE i&lt;iCount DO                  #IF i&lt;10 THEN SET table_name=CONCAT(table_pre,i);                      #    ELSE SET table_name=CONCAT(table_pre,i);                      #END IF;                  SET table_name=CONCAT(table_pre,i);                  SET sql_text=CONCAT(&apos;CREATE TABLE &apos;, table_name, &apos;(                   id INT(11) NOT NULL COMMENT \&apos;用户id\&apos; AUTO_INCREMENT,                   userName VARCHAR(32)  COMMENT \&apos;用户名\&apos;,                   service INT(11) DEFAULT 0 COMMENT \&apos;服务\&apos;,                   passportUserName VARCHAR(32)  COMMENT \&apos;y\&apos;,                   email  VARCHAR(32) COMMENT \&apos;email\&apos;,                   phone  VARCHAR(15) COMMENT \&apos;电话\&apos;,                       trueName  VARCHAR(12) COMMENT \&apos;真实姓名\&apos;,                       idNumber  VARCHAR(18) COMMENT \&apos;身份证\&apos;,                       nickName  VARCHAR(32) COMMENT \&apos;昵称\&apos;,                       maxMsgId  INT(18) COMMENT \&apos;消息id\&apos;,                       gameIds  VARCHAR(32)DEFAULT null COMMENT \&apos;昵称？\&apos;,                       crmVip  INT(11) COMMENT \&apos;消息id\&apos;,                       status  INT(11) COMMENT \&apos;状态\&apos;,                       updateTime  Date COMMENT \&apos;更新时间\&apos;,                  bigHead  VARCHAR(200)DEFAULT null COMMENT \&apos;bigHead\&apos;,                  smallHead  VARCHAR(200)DEFAULT null COMMENT \&apos;smallHead\&apos;,                  cmos_modify_time datetime(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3) ON UPDATE CURRENT_TIMESTAMP(3),                  PRIMARY KEY (id),                  KEY idx_cmos_modify_time (cmos_modify_time)                    ) ENGINE=INNODB DEFAULT CHARSET=utf8&apos; );                  SELECT sql_text;                   SET @sql_text=sql_text;                  PREPARE stmt FROM @sql_text;                  EXECUTE stmt;                  DEALLOCATE PREPARE stmt;                    SET i=i+1;              END WHILE;          END$$      DELIMITER ;      ---------------批量删表----------------------------------      DELIMITER $$      CREATE  PROCEDURE `delTables`( IN table_pre VARCHAR(20),IN iCount INT)      BEGIN              DECLARE i INT;              DECLARE table_name VARCHAR(50);                DECLARE sql_text VARCHAR(2000);               SET i=0;              SET table_name=&apos;&apos;;              SET sql_text=&apos;&apos;;              WHILE i&lt;iCount DO                  SET table_name=CONCAT(table_pre,i);                  SET sql_text=CONCAT(&apos;DROP TABLE IF EXISTS &apos;, table_name, &apos;;&apos; );                  SELECT sql_text;                   SET @sql_text=sql_text;                  PREPARE stmt FROM @sql_text;                  EXECUTE stmt;                  DEALLOCATE PREPARE stmt;                    SET i=i+1;              END WHILE;          END$$      DELIMITER ;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;操作如下： 

      CREATE TABLE `tstudent4` (
        `studentID` int(15) NOT NULL,
        `Sname` varchar(64) DEFAULT NULL,
        
      
    
    </summary>
    
      <category term="数据库" scheme="https://liuhusen.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="存储过程" scheme="https://liuhusen.com/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    
      <category term="数据库相关操作" scheme="https://liuhusen.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>多线程访问成员变量与局部变量</title>
    <link href="https://liuhusen.com/2018/10/11/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://liuhusen.com/2018/10/11/成员变量和局部变量与多线程/</id>
    <published>2018-10-11T08:21:30.000Z</published>
    <updated>2019-03-22T03:14:57.769Z</updated>
    
    <content type="html"><![CDATA[<pre><code>       public class HelloThreadTest    {        public static void main(String[] args)        {            HelloThread r = new HelloThread();            Thread t1 = new Thread(r);            Thread t2 = new Thread(r);            t1.start();            t2.start();        }    }    class HelloThread implements Runnable    {        int i;        @Override        public void run()        {            while (true)            {                System.out.println(&quot;Hello number: &quot; + i++);                try                {                    Thread.sleep((long) Math.random() * 1000);                }                catch (InterruptedException e)                {                    e.printStackTrace();                }                if (50 == i)                {                    break;                }            }        }    }该例子中，HelloThread类实现了Runnable接口，其中run()方法的主要工作是输出&quot;Hello number: &quot;字符串加数字i，并且同时递增i，当i到达50时，退出循环。　　main()方法中生成了一个HelloThread类的对象r，并且利用这个一个对象生成了两个线程。　　程序的执行结果是：顺次打印了0到49的数字，共50个数字。　　这是因为，i是成员变量，则HelloThread的对象r只包含这一个i，两个Thread对象因为由r构造，所以共享了同一个i。　　当我们改变代码如下时（原先的成员变量i被注释掉，增加了方法中的局部变量i）：public class HelloThreadTest    {        public static void main(String[] args)        {            HelloThread r = new HelloThread();            Thread t1 = new Thread(r);            Thread t2 = new Thread(r);            t1.start();            t2.start();        }    }    class HelloThread implements Runnable    {        // int i;        // 若i是成员变量，则HelloThread的对象r只包含这一个i，两个Thread对象因为由r构造，所以共享了同一个i        // 打印结果是0到49的数字        @Override        public void run()        {            int i = 0;            // 每一个线程都会拥有自己的一份局部变量的拷贝            // 线程之间互不影响            // 所以会打印100个数字，0到49每个数字都是两遍            while (true)            {                System.out.println(&quot;Hello number: &quot; + i++);                try                {                    Thread.sleep((long) Math.random() * 1000);                }                catch (InterruptedException e)                {                    e.printStackTrace();                }                if (50 == i)                {                    break;                }            }        }    }    如注释中所述，由于局部变量对于每一个线程来说都有自己的拷贝，所以各个线程之间不再共享同一个变量，    输出结果为100个数字，实际上是两组，每组都是0到49的50个数字，并且两组数字之间随意地穿插在一起。　得到的结论如下：　　如果一个变量是成员变量，那么多个线程对同一个对象的成员变量进行操作时，它们对该成员变量是彼此影响的，也就是说一个线程对成员变量的改变会影响到另一个线程。　　如果一个变量是局部变量，那么每个线程都会有一个该局部变量的拷贝（即便是同一个对象中的方法的局部变量，也会对每一个线程有一个拷贝），一个线程对该局部变量的改变不会影响到其他线程。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;       public class HelloThreadTest
    {
        public static void main(String[] args)
        {
            HelloThread r = ne
      
    
    </summary>
    
      <category term="关于日志" scheme="https://liuhusen.com/categories/%E5%85%B3%E4%BA%8E%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="多线程" scheme="https://liuhusen.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Solr单机版服务搭建</title>
    <link href="https://liuhusen.com/2018/10/08/Solr%E5%8D%95%E6%9C%BA%E7%89%88%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"/>
    <id>https://liuhusen.com/2018/10/08/Solr单机版服务搭建/</id>
    <published>2018-10-08T05:01:30.000Z</published>
    <updated>2019-03-01T06:48:45.132Z</updated>
    
    <content type="html"><![CDATA[<p>   Solr服务搭建<br>      1、solr的环境:solr是Java开发，需要安装JDK，安装环境Linux，需要安装Tomcat。<br>      2、搭建步骤：<br>            第一步： 把solr的压缩包上传到Linux系统<br>            第二步： 解压solr<br>            第三步： 安装Tomcat，解压缩即可。<br>            第四步： 把solr部署到Tomcat下。<br>            第五步： 解压缩war包。启动<br>            第六步： 把/root/solr-4.10.3/example/lib/ext 目录下的所有的jar包，添加到 solr 工程中。<br>            [root@localhost ext]# pwd<br>            /root/solr-4.10.3/example/lib/ext<br>            [root@localhost ext]# cp* /usr/local/solr/tomcat/webapps/solr/WEB-INF/lib/<br>            第七步： 创建一个 solrhome. /exanple/solr 目录就是一个 solrhome. 复制此目录到 /usr/local/solr/solrhome<br>            [root@localhost example]# pwd<br>            /root/solr-4.10.3/example<br>            [root@localhost example]# cp -r solr /usr/local/solr/solrhome<br>            [root@localhost example]#<br>            第八步：关联solr及solrhome。需要修改solr工程的web.xml文件<br>             <img src="/2018/10/08/Solr单机版服务搭建/01.png" alt="你想输入的替代文字"><br>            第九步：启动Tomcat<br>                    <a href="http://192.168.25.154:8080/solr/" target="_blank" rel="noopener">http://192.168.25.154:8080/solr/</a><br>                    和windows下的配置完全一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   Solr服务搭建&lt;br&gt;      1、solr的环境:solr是Java开发，需要安装JDK，安装环境Linux，需要安装Tomcat。&lt;br&gt;      2、搭建步骤：&lt;br&gt;            第一步： 把solr的压缩包上传到Linux系统&lt;br&gt;    
      
    
    </summary>
    
      <category term="服务搭建" scheme="https://liuhusen.com/categories/%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Solr单机版服务搭建" scheme="https://liuhusen.com/tags/Solr%E5%8D%95%E6%9C%BA%E7%89%88%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>常见框架单例、多例与线程安全性总结</title>
    <link href="https://liuhusen.com/2018/08/08/%E5%B8%B8%E8%A7%81%E6%A1%86%E6%9E%B6%E5%8D%95%E4%BE%8B%E3%80%81%E5%A4%9A%E4%BE%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <id>https://liuhusen.com/2018/08/08/常见框架单例、多例与线程安全性总结/</id>
    <published>2018-08-08T05:01:30.000Z</published>
    <updated>2019-03-22T03:23:51.435Z</updated>
    
    <content type="html"><![CDATA[<pre><code>   单例与多例问题是指，当多个用户访问某个类时，系统是为每个用户创建一个该类实例，还是整个系统无论多少用户访问，只创建一个该类实例。线程安全问题是指，多个用户同时在访问同一个程序时，其对于某一数据的修改，会不会影响到其他用户中的该数据。若没有影响，则是线程安全的;若有可能影响，则是线程不安全的。现在对 HttpServlet、HttpSession、SpingMVC、Struts2 中的 Action、Hibernate 中的 SessionFactory与 Session，进行总结。 (1)HttpServlet    其是单例的。即无论多少用户访问同一个业务，如 LoginServlet，Web 容器只会创建一个该 Servlet 实例。而该实例是允许多用户访问的。    若 Servlet 中包含成员变量，则每个用户对于成员变量的修改，均会影响到其他用户所看到的该变量的值，所以这时是线程不安全的。    若不包含成员变量，则是线程安全的。(2)HttpSession    其是多例的。Web 容器会为每个用户开辟一个 Session，多个用户会有多个 Session。而每个用户只能访问自己的 Session。    所以，对于 Session 来说，就不存在并发访问的情况，也就不存在线程安全的问题了。所以可以说是线程安全的。(3)SpingMVC Controller    Spring MVC Controller默认是单例的：    单例的原因有二：    1、为了性能。    2、不需要多例。    如果需要多例，则需要在Controller类上加注解 @Scope(“prototype”)(4)Struts2 的 Action    其是多例的。对于同一个业务，例如 LoginAction，系统会为每一个用户创建一个LoginAction 的实例，    并使其成员变量 username 与 password 接收用户 交的数据。同一用户只能访问自己的 Action。    所以，对于 Action 来说，就不存在并发访问的情况，也就不存在线程安全的问题了。所以可以说是线程安全的。 (5)Hibernate 的 SessionFactory    其是单例的。无论多少用户访问该项目，系统只会创建一个 SessionFactory 对象，即这个对象是可以被所有用户访问的。    SessionFactory实现类中所包含的成员变量基本都是 final常量，即任何用户均不能修改。所以，也就不存在用户的修改对其他用户的影响问题了，所以是线程安全的。 (6)Hibernate 的 Session    其是多例的。系统会为每个用户创建一个 Sessio。    Session 的实现类中定义了很多的非 final 成员变量，一个事务对成员变量所做的修改，会影响到另一个事务对同一数据的访问结果，所以是线程不安全的。 </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;   单例与多例问题是指，当多个用户访问某个类时，系统是为每个用户创建一个该类实例，还是整个系统无论多少用户访问，只创建一个该类实例。

线程安全问题是指，多个用户同时在访问同一个程序时，其对于某一数据的修改，会不会影响到其他用户中的该数据。若没有影响，则是
      
    
    </summary>
    
      <category term="关于日志" scheme="https://liuhusen.com/categories/%E5%85%B3%E4%BA%8E%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="多例，多线程" scheme="https://liuhusen.com/tags/%E5%A4%9A%E4%BE%8B%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>常用的扒拉后台日志操作命令</title>
    <link href="https://liuhusen.com/2018/08/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%89%92%E6%8B%89%E5%90%8E%E5%8F%B0%E6%97%A5%E5%BF%97%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
    <id>https://liuhusen.com/2018/08/08/常用的扒拉后台日志操作命令/</id>
    <published>2018-08-08T05:01:30.000Z</published>
    <updated>2019-01-18T07:06:06.361Z</updated>
    
    <content type="html"><![CDATA[<p>   翻找环境上的日志：<br>              ll                                     展示目录<br>              cd                                     进入含有日志文件的文件夹目录<br>              tail -200f 文件名                      实时查看200行日志<br>              cat 文件名 | grep “关键字” -A 页数     展示出含有关键字的后面的页数<br>              cat 文件名 | grep “关键字” -B 页数     展示出含有关键字的前面的页数<br>              cat 文件名 | grep “关键字” -C 页数     展示出含有关键字的上下文的页数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   翻找环境上的日志：&lt;br&gt;              ll                                     展示目录&lt;br&gt;              cd                                     进入含有日志文
      
    
    </summary>
    
      <category term="关于日志" scheme="https://liuhusen.com/categories/%E5%85%B3%E4%BA%8E%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="生产日志" scheme="https://liuhusen.com/tags/%E7%94%9F%E4%BA%A7%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>redis的安装与集群搭建</title>
    <link href="https://liuhusen.com/2018/02/08/redis%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>https://liuhusen.com/2018/02/08/redis的安装与集群搭建/</id>
    <published>2018-02-08T05:01:30.000Z</published>
    <updated>2019-02-28T11:40:30.824Z</updated>
    
    <content type="html"><![CDATA[<p>   Redis是C语言开发的。<br>   安装Redis需要C语言的编译环境。如果没有gcc 需要在线安装。 Yum install gcc-c++</p><p>   安装步骤：<br>        第一步： Redis的源码包上传到Linux系统。<br>        第二步： 解压缩Redis。<br>        第三步： 编译  make<br>        第四步： 安装  make install PREFIX=/usr/local/redis</p><p>   连接Redis：<br>        1.Redis的启动：<br>            前端启动：[root@localhost bin]# ./redis-server<br>            后台启动： 把 /root/redis-3.0.0/redis.conf 复制到 /usr/local/redis/bin目录下<br>                      [root@localhost bin]# cp redis.conf  /usr/local/redis/bin/<br>            修改配置文件：<br>             <img src="/2018/02/08/redis的安装与集群搭建/01.png" alt="你想输入的替代文字"><br>             [root@localhost bin]# ./redis-server redis.conf<br>             查看Redis进程：<br>                            [root@localhost bin]# ps aux|grep redis<br>                            root      5190  0.1  0.3  33936  1712 ?        Ssl  18:23   0:00 ./redis-server *:6379<br>                            root      5196  0.0  0.1   4356   728 pts/0    S+   18:24   0:00 grep redis<br>                            [root@localhost bin]#<br>        2.Redis-cli<br>            [root@localhost bin]# ./redis-cli<br>            默认连接localhost运行在6379端口的Redis服务<br>            [root@localhost bin]# ./redis-cli -h 192.168.25.153 -p 6379<br>            -h : 连接的服务器地址<br>            -p : 服务的端口号</p><pre><code>3.Redis五种数据类型   String : key-value (做缓存)     Hash ：key-fields-values (做缓存)     List : 有顺序可重复      Set ：无顺序，不能重复SortedSet(zset) : 有顺序，不能重复4.Redis集群的搭建   （1） redis-cluster 架构图        ![你想输入的替代文字](redis的安装与集群搭建/02.png)        架构细节：             1.所有的Redis节点彼此互联（ping-pong机制），内部使用二进制协议优化传输速度和带宽             2.节点的fail是通过集群中超过半数的节点检测失效时才生效             3.客户端与Redis节点直连，不需要中间proxy层，客户端不需要连接集群所有节点，               连接集群中任何一个可用节点即可             4.redis-cluster 把所有的物理节点映射到 [0-16383] slot上，cluster负责维护               node&lt;-&gt;slot&lt;-&gt;node               Redis 集群中内置了 16384 个哈希槽，当需要在 redis集群中放置一个 key-value 时，               redis 先对 key 使用 crc16算法算出一个结果，然后把结果对 16384 求余，这样每个 key 都               会对应一个编号在 0-16383 之间的哈希槽，redis会根据节点数量大致均等的将哈希槽映射到               不同的节点   （2） 1、 使用ruby脚本搭建集群。需要ruby的运行环境。             安装 ruby             yum install ruby             yum install rubygems         2、 安装 ruby 脚本运行使用的包             [root@localhost ~]#  gem install redis-3.0.0.gem             Successfully installed redis-3.0.0             1 gem installed             Installing ri documentation for redis-3.0.0...             Installing RDoc documentation for redis-3.0.0...             [root@localhost ~]#              [root@localhost ~]#  redis-3.0.0/src             [root@localhost ~]#  ll*.rb             -rwxrwxr-x. 1 root root 48141 Apr  1  2015 redis-trib.rb         3、 搭建步骤             需要6台redis服务器。搭建伪分布式。             需要6个redis实例。             需要运行在不同的端口 7001-7006             第一步：创建6个redis实例，每个实例运行在不同的端口。需要修改redis.conf配置文件。                     配置文件中还需要把 cluster-enabled yes 前的注释去掉                     ![你想输入的替代文字](redis的安装与集群搭建/03.png)             第二步：启动每个redis实例。             第三步：使用ruby脚本搭建集群。                     ./redis-trib.rb create --replicas 1 192.168.25.153:7001 192.168.25.153:7002                       192.168.25.153:7003 192.168.25.153:7004 192.168.25.153:7005  192.168.25.153:7006                      创建关闭集群的脚本：                       [root@localhost redis-cluster]# vim shutdow-all.sh                      redis01/redis-cli -p 7001 shutdown                      redis01/redis-cli -p 7002 shutdown                      redis01/redis-cli -p 7003 shutdown                      redis01/redis-cli -p 7004 shutdown                      redis01/redis-cli -p 7005 shutdown                      redis01/redis-cli -p 7006 shutdown                      [root@localhost redis-cluster]# chomd u+x shutdown-all.sh                      [root@localhost redis-cluster]# ./redis-trib.rb create --replicas 1 192.168.25.153:7001                      192.168.25.153:7002 192.168.25.153:7003 192.168.25.153:7004 192.168.25.153:7005                      192.168.25.153:7006                      &gt;&gt;&gt; Creating cluster                      Connecting to node 192.168.25.153:7001: OK                      Connecting to node 192.168.25.153:7002: OK                      Connecting to node 192.168.25.153:7003: OK                      Connecting to node 192.168.25.153:7004: OK                      Connecting to node 192.168.25.153:7005: OK                      Connecting to node 192.168.25.153:7006: OK                      &gt;&gt;&gt; Performing hash slots allocation on 6 nodes...                      Using 3 masters:                      192.168.25.153:7001                      192.168.25.153:7002                      192.168.25.153:7003                      Adding replica 192.168.25.153:7004 to 192.168.25.153:7001                      Adding replica 192.168.25.153:7005 to 192.168.25.153:7002                      Adding replica 192.168.25.153:7006 to 192.168.25.153:7003                      M: 2e48ae301e9c32b04a7d4d92e15e98e78de8c1f3 192.168.25.153:7001                         slots:0-5460 (5461 slots) master                      M: 8cd93a9a943b4ef851af6a03edd699a6061ace01 192.168.25.153:7002                         slots:5461-10922 (5462 slots) master                      M: 2935007902d83f20b1253d7f43dae32aab9744e6 192.168.25.153:7003                         slots:10923-16383 (5461 slots) master                      S: 74f9d9706f848471583929fc8bbde3c8e99e211b 192.168.25.153:7004                         replicates 2e48ae301e9c32b04a7d4d92e15e98e78de8c1f3                      S: 42cc9e25ebb19dda92591364c1df4b3a518b795b 192.168.25.153:7005                         replicates 8cd93a9a943b4ef851af6a03edd699a6061ace01                      S: 8b1b11d509d29659c2831e7a9f6469c060dfcd39 192.168.25.153:7006                         replicates 2935007902d83f20b1253d7f43dae32aab9744e6                      Can I set the above configuration? (type &apos;yes&apos; to accept): yes                      &gt;&gt;&gt; Nodes configuration updated                      &gt;&gt;&gt; Assign a different config epoch to each node                      &gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster                      Waiting for the cluster to join.....                      &gt;&gt;&gt; Performing Cluster Check (using node 192.168.25.153:7001)                      M: 2e48ae301e9c32b04a7d4d92e15e98e78de8c1f3 192.168.25.153:7001                         slots:0-5460 (5461 slots) master                      M: 8cd93a9a943b4ef851af6a03edd699a6061ace01 192.168.25.153:7002                         slots:5461-10922 (5462 slots) master                      M: 2935007902d83f20b1253d7f43dae32aab9744e6 192.168.25.153:7003                         slots:10923-16383 (5461 slots) master                      M: 74f9d9706f848471583929fc8bbde3c8e99e211b 192.168.25.153:7004                         slots: (0 slots) master                         replicates 2e48ae301e9c32b04a7d4d92e15e98e78de8c1f3                      M: 42cc9e25ebb19dda92591364c1df4b3a518b795b 192.168.25.153:7005                         slots: (0 slots) master                         replicates 8cd93a9a943b4ef851af6a03edd699a6061ace01                      M: 8b1b11d509d29659c2831e7a9f6469c060dfcd39 192.168.25.153:7006                         slots: (0 slots) master                         replicates 2935007902d83f20b1253d7f43dae32aab9744e6                      [OK] All nodes agree about slots configuration.                      &gt;&gt;&gt; Check for open slots...                      &gt;&gt;&gt; Check slots coverage...                      [OK] All 16384 slots covered.                      [root@localhost redis-cluster]# 5、 集群的使用方法    Redis-cli 连接集群    。    [root@localhost redis-cluster]# redis01/redis-cli -p 7002 -c    -c: 代表连接的是redis集群</code></pre><p>   （3） Jedis<br>         需要把jedis依赖的jar包添加到工程中。Maven工程中需要把jedis的坐标添加到依赖。<br>         推荐添加到服务层。Taotao-content-Service 工程中</p><pre><code>     1. 连接单机版        第一步：创建一个Jedis对象。需要指定服务端的IP及端口。        第二步：使用Jedis对象操作数据库，每个Jedis命令对应一个方法。        第三步：打印结果。        第四步：关闭Jedis        代码如下：        @Test            public void testJedis() throws Exception {                // 第一步：创建一个Jedis对象。需要指定服务端的ip及端口。                Jedis jedis = new Jedis(&quot;192.168.25.153&quot;, 6379);                // 第二步：使用Jedis对象操作数据库，每个redis命令对应一个方法。                String result = jedis.get(&quot;hello&quot;);                // 第三步：打印结果。                System.out.println(result);                // 第四步：关闭Jedis                jedis.close();            }          2、连接单机版使用连接池          第一步： 创建一个JedisPool对象。需要指定服务器的IP及端口。          第二步： 从JedisPool中获取Jedis对象。          第三步： 使用Jedis操作redis服务器          第四步： 使用完毕后关闭jedis对象，连接池回收资源。          第五步： 关闭JedisPool对象。          代码如下：            @Test            public void testJedisPool() throws Exception {                // 第一步：创建一个JedisPool对象。需要指定服务端的ip及端口。                JedisPool jedisPool = new JedisPool(&quot;192.168.25.153&quot;, 6379);                // 第二步：从JedisPool中获得Jedis对象。                Jedis jedis = jedisPool.getResource();                // 第三步：使用Jedis操作redis服务器。                jedis.set(&quot;jedis&quot;, &quot;test&quot;);                String result = jedis.get(&quot;jedis&quot;);                System.out.println(result);                // 第四步：操作完毕后关闭jedis对象，连接池回收资源。                jedis.close();                // 第五步：关闭JedisPool对象。                jedisPool.close();            }           3、连接集群版         第一步: 使用JedisCluster对象。需要一个 Set&lt;HostAndPost&gt; 参数。Redis 节点列表。         第二步：直接使用JedisCluster对象操作redis。在系统中单例存在。         第三步：打印结果。                第四步：系统关闭前，关闭JedisCluster对象。         代码如下：        @Test        public void testJedisCluster() throws Exception {            // 第一步：使用JedisCluster对象。需要一个Set&lt;HostAndPort&gt;参数。Redis节点的列表。            Set&lt;HostAndPort&gt; nodes = new HashSet&lt;&gt;();            nodes.add(new HostAndPort(&quot;192.168.25.153&quot;, 7001));            nodes.add(new HostAndPort(&quot;192.168.25.153&quot;, 7002));            nodes.add(new HostAndPort(&quot;192.168.25.153&quot;, 7003));            nodes.add(new HostAndPort(&quot;192.168.25.153&quot;, 7004));            nodes.add(new HostAndPort(&quot;192.168.25.153&quot;, 7005));            nodes.add(new HostAndPort(&quot;192.168.25.153&quot;, 7006));            JedisCluster jedisCluster = new JedisCluster(nodes);            // 第二步：直接使用JedisCluster对象操作redis。在系统中单例存在。            jedisCluster.set(&quot;hello&quot;, &quot;100&quot;);            String result = jedisCluster.get(&quot;hello&quot;);            // 第三步：打印结果            System.out.println(result);            // 第四步：系统关闭前，关闭JedisCluster对象。            jedisCluster.close();        }    （4）、实际使用案例：在实际业务逻辑的添加缓存            1、 接口封装            常用的操作redis的方法提取出一个接口，分别对应单机版和集群版创建两个实现类。        2、 单机版接口定义            public interface JedisClient {                String set(String key, String value);                String get(String key);                Boolean exists(String key);                Long expire(String key, int seconds);                Long ttl(String key);                Long incr(String key);                Long hset(String key, String field, String value);                String hget(String key, String field);                Long hdel(String key, String... field);            }            3、 单机版实现类             public class JedisClientPool implements JedisClient {                @Autowired                private JedisPool jedisPool;                @Override                public String set(String key, String value) {                    Jedis jedis = jedisPool.getResource();                    String result = jedis.set(key, value);                    jedis.close();                    return result;                }                @Override                public String get(String key) {                    Jedis jedis = jedisPool.getResource();                    String result = jedis.get(key);                    jedis.close();                    return result;                }                @Override                public Boolean exists(String key) {                    Jedis jedis = jedisPool.getResource();                    Boolean result = jedis.exists(key);                    jedis.close();                    return result;                }                @Override                public Long expire(String key, int seconds) {                    Jedis jedis = jedisPool.getResource();                    Long result = jedis.expire(key, seconds);                    jedis.close();                    return result;                }                @Override                public Long ttl(String key) {                    Jedis jedis = jedisPool.getResource();                    Long result = jedis.ttl(key);                    jedis.close();                    return result;                }                @Override                public Long incr(String key) {                    Jedis jedis = jedisPool.getResource();                    Long result = jedis.incr(key);                    jedis.close();                    return result;                }                @Override                public Long hset(String key, String field, String value) {                    Jedis jedis = jedisPool.getResource();                    Long result = jedis.hset(key, field, value);                    jedis.close();                    return result;                }                @Override                public String hget(String key, String field) {                    Jedis jedis = jedisPool.getResource();                    String result = jedis.hget(key, field);                    jedis.close();                    return result;                }                @Override                public Long hdel(String key, String... field) {                    Jedis jedis = jedisPool.getResource();                    Long result = jedis.hdel(key, field);                    jedis.close();                    return result;                }            }                    配置applicationContext-redis.xml         &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;            &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;                xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;                xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;                xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;                xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans4.2.xsd                http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context4.2.xsd                http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx4.2.xsd                http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util4.2.xsd&quot;&gt;                &lt;!--配置单机版的连接--&gt;                &lt;bean id=&quot;jedisPool&quot; class=&quot;redis.client.jedis.JedisPool&quot;&gt;                      &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.153&quot;&gt; &lt;/constructor-arg&gt;                      &lt;constructor-arg name=&quot;port&quot; value=&quot;6379&quot;&gt; &lt;/constructor-arg&gt;                &lt;/bean&gt;                &lt;bean id=&quot;jedisClientPool&quot; class=&quot;com.taotao.jedis.JedisClientPool&quot; /&gt;            &lt;/beans&gt;        集群版实现类：           代码如下：            package com.taotao.jedis;                import org.springframework.beans.factory.annotation.Autowired;                import redis.clients.jedis.JedisCluster;                public class JedisClientCluster implements JedisClient {                    @Autowired                    private JedisCluster jedisCluster;                    @Override                    public String set(String key, String value) {                        return jedisCluster.set(key, value);                    }                    @Override                    public String get(String key) {                        return jedisCluster.get(key);                    }                    @Override                    public Boolean exists(String key) {                        return jedisCluster.exists(key);                    }                    @Override                    public Long expire(String key, int seconds) {                        return jedisCluster.expire(key, seconds);                    }                    @Override                    public Long ttl(String key) {                        return jedisCluster.ttl(key);                    }                    @Override                    public Long incr(String key) {                        return jedisCluster.incr(key);                    }                    @Override                    public Long hset(String key, String field, String value) {                        return jedisCluster.hset(key, field, value);                    }                    @Override                    public String hget(String key, String field) {                        return jedisCluster.hget(key, field);                    }                    @Override                    public Long hdel(String key, String... field) {                        return jedisCluster.hdel(key, field);                    }                }            Spring的配置：                 &lt;!-- 集群版的配置 --&gt;                        &lt;bean id=&quot;jedisCluster&quot; class=&quot;redis.clients.jedis.JedisCluster&quot;&gt;                            &lt;constructor-arg&gt;                               &lt;set&gt;                                    &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;                                          &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.153&quot;&gt; &lt;/constructor-arg&gt;                                          &lt;constructor-arg name=&quot;port&quot; value=&quot;7001&quot;&gt; &lt;/constructor-arg&gt;                                    &lt;/beans&gt;                                    &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;                                          &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.153&quot;&gt; &lt;/constructor-arg&gt;                                          &lt;constructor-arg name=&quot;port&quot; value=&quot;7002&quot;&gt; &lt;/constructor-arg&gt;                                    &lt;/beans&gt;                                    &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;                                        &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.153&quot;&gt;&lt;/constructor-arg&gt;                                        &lt;constructor-arg name=&quot;port&quot; value=&quot;7003&quot;&gt;&lt;/constructor-arg&gt;                                    &lt;/bean&gt;                                    &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;                                        &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.153&quot;&gt;&lt;/constructor-arg&gt;                                        &lt;constructor-arg name=&quot;port&quot; value=&quot;7004&quot;&gt;&lt;/constructor-arg&gt;                                    &lt;/bean&gt;                                    &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;                                        &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.153&quot;&gt;&lt;/constructor-arg&gt;                                        &lt;constructor-arg name=&quot;port&quot; value=&quot;7005&quot;&gt;&lt;/constructor-arg&gt;                                    &lt;/bean&gt;                                    &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;                                        &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.153&quot;&gt;&lt;/constructor-arg&gt;                                        &lt;constructor-arg name=&quot;port&quot; value=&quot;7006&quot;&gt;&lt;/constructor-arg&gt;                                    &lt;/bean&gt;                                &lt;/set&gt;                            &lt;/constructor-arg&gt;                        &lt;/bean&gt;                        &lt;bean id=&quot;jedisClientCluster&quot; class=&quot;com.taotao.jedis.JedisClientCluster&quot; /&gt;                        注意： 单机版和集群版不能共存，使用单机版时注释集群版的配置。使用集群版，把单机版注释。                        工作中常用的业务：（注意：添加缓存时不能影响正常业务逻辑）                            1.大数据量查询时:                                  查数据库之前先查询缓存，查到结果就直接响应结果，查不到则                                  缓存中没有，需要查询数据库，把查询结果添加到缓存中。                                  还需要考虑到一点  ： 缓存同步-- 对内容信息做增删改查操作后把对应缓存删除即可。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   Redis是C语言开发的。&lt;br&gt;   安装Redis需要C语言的编译环境。如果没有gcc 需要在线安装。 Yum install gcc-c++&lt;/p&gt;
&lt;p&gt;   安装步骤：&lt;br&gt;        第一步： Redis的源码包上传到Linux系统。&lt;br&gt;    
      
    
    </summary>
    
      <category term="redis" scheme="https://liuhusen.com/categories/redis/"/>
    
    
      <category term="redis" scheme="https://liuhusen.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>关于Hexo更换git账号的步骤记录</title>
    <link href="https://liuhusen.com/2017/06/08/%E5%85%B3%E4%BA%8EHexo%E6%9B%B4%E6%8D%A2git%E8%B4%A6%E5%8F%B7%E7%9A%84%E6%AD%A5%E9%AA%A4%E8%AE%B0%E5%BD%95/"/>
    <id>https://liuhusen.com/2017/06/08/关于Hexo更换git账号的步骤记录/</id>
    <published>2017-06-08T05:01:30.000Z</published>
    <updated>2019-04-02T02:42:14.207Z</updated>
    
    <content type="html"><![CDATA[<pre><code>操作如下：   1.编辑_config.yml(在\hexo下)。你在部署时，要把下面的都换成你的账号名。      deploy:        type: git        repo: git@github.com:liuhusen/liuhusen.github.io.git          branch: master   2.更换你本地的git用户名和邮箱，命令如下         查看当前用户名：git config user.name         查看当前邮箱（注册git账号的邮箱）：git config user.email         更改用户名：git config --global user.name &quot;liuhusen&quot;         更改邮箱：git config --global user.email &quot;l_Striving@163.com&quot;  3.生成你的ssh密钥，命令如下：        生成密钥： ssh-keygen -t rsa -C &quot;l_Striving@163.com&quot;        三次回车，设置密码为空        将生成的C:\Users\Administrator.ssh目录下的id_rsa.pub添加到github上  4. 清理：hexo c     生成静态资源： hexo g      推送到git上：  hexo d     重新在git上设置你的访问域名     设置完毕，大功告成！</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;操作如下： 
  1.编辑_config.yml(在\hexo下)。你在部署时，要把下面的都换成你的账号名。
      deploy:
        type: git
        repo: git@github.com:liuhusen/liuh
      
    
    </summary>
    
      <category term="其他" scheme="https://liuhusen.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="hexo" scheme="https://liuhusen.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>简单有效的页面防止重复提交的操作</title>
    <link href="https://liuhusen.com/2017/06/08/%E7%AE%80%E5%8D%95%E6%9C%89%E6%95%88%E7%9A%84%E9%A1%B5%E9%9D%A2%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>https://liuhusen.com/2017/06/08/简单有效的页面防止重复提交的操作/</id>
    <published>2017-06-08T05:01:30.000Z</published>
    <updated>2018-10-31T07:41:51.026Z</updated>
    
    <content type="html"><![CDATA[<pre><code>操作如下：     var isSubmit = true; // 在js顶部定义全局变量    if(isSubmit){       save();    }else{       crossAPI.tips(&quot;请勿重复提交数据！&quot;,3000);       return false;    }    var save = function () {          isSubmit = false; // 进入方法后 isSubmit 置为 false，在后续的点击提交时，便不会执行save方法          。。。          。。。 // 此处为你自己的执行保存的方法          if( 保存成功 ){             关闭数据新增页面，并刷新查询页面的查询          }else{             // 保存失败，则页面提醒保存失败             isSubmit = true;  // isSubmit 置为 true ,用以再次提交当前数据使用          }    }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;操作如下： 

    var isSubmit = true; // 在js顶部定义全局变量

    if(isSubmit){
       save();
    }else{
       crossAPI.tips(&amp;quot;请勿重复提交数据！
      
    
    </summary>
    
      <category term="javascript" scheme="https://liuhusen.com/categories/javascript/"/>
    
    
      <category term="javascript页面效果" scheme="https://liuhusen.com/tags/javascript%E9%A1%B5%E9%9D%A2%E6%95%88%E6%9E%9C/"/>
    
      <category term="防止重复提交" scheme="https://liuhusen.com/tags/%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4/"/>
    
  </entry>
  
  <entry>
    <title>接口传输时对乱码的处理</title>
    <link href="https://liuhusen.com/2017/05/26/%E6%8E%A5%E5%8F%A3%E4%BC%A0%E8%BE%93%E6%97%B6%E5%AF%B9%E4%B9%B1%E7%A0%81%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>https://liuhusen.com/2017/05/26/接口传输时对乱码的处理/</id>
    <published>2017-05-26T11:57:47.000Z</published>
    <updated>2019-04-02T02:51:36.941Z</updated>
    
    <content type="html"><![CDATA[<pre><code>传输前编码：// 先对用户名进行解码得到%E7%8E%8B%E6%8C%AF%E5%9B%BD 这样的形式username = URLEncoder.encode(username, &quot;ISO-8859-1&quot;);获取后解码：username = URLDecoder.decode(username, &quot;UTF-8&quot;);System.out.println(&quot;乱码解决后用户名：&quot; + username)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;传输前编码：
// 先对用户名进行解码得到%E7%8E%8B%E6%8C%AF%E5%9B%BD 这样的形式
username = URLEncoder.encode(username, &amp;quot;ISO-8859-1&amp;quot;);

获取后解码：
us
      
    
    </summary>
    
      <category term="接口传输" scheme="https://liuhusen.com/categories/%E6%8E%A5%E5%8F%A3%E4%BC%A0%E8%BE%93/"/>
    
    
      <category term="接口传输" scheme="https://liuhusen.com/tags/%E6%8E%A5%E5%8F%A3%E4%BC%A0%E8%BE%93/"/>
    
      <category term="post请求传输" scheme="https://liuhusen.com/tags/post%E8%AF%B7%E6%B1%82%E4%BC%A0%E8%BE%93/"/>
    
      <category term="get请求传输" scheme="https://liuhusen.com/tags/get%E8%AF%B7%E6%B1%82%E4%BC%A0%E8%BE%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的表增删字段和增删索引</title>
    <link href="https://liuhusen.com/2017/05/26/MySQL%E7%9A%84%E8%A1%A8%E5%A2%9E%E5%88%A0%E5%AD%97%E6%AE%B5%E5%92%8C%E5%A2%9E%E5%88%A0%E7%B4%A2%E5%BC%95/"/>
    <id>https://liuhusen.com/2017/05/26/MySQL的表增删字段和增删索引/</id>
    <published>2017-05-26T11:57:47.000Z</published>
    <updated>2018-10-28T19:13:31.613Z</updated>
    
    <content type="html"><![CDATA[<pre><code>表添加字段： ALTER TABLE 表名 ADD COLUMN 表字段 varchar(50) DEFAULT NULL COMMENT &apos;字段描述&apos;;表删除字段： ALTER TABLE 表名 DROP COLUMN  表字段 ;字段建唯一索引：create index idx_province_id on 表名 (表字段 );                               上为索引                create index 字段的索引 on 表名 (表字段 );               删除字段的索引：alter table 表名 drop index idx_province_id ;                                        上为索引                alter table 表名 drop 字段的索引 ;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;表添加字段： ALTER TABLE 表名 ADD COLUMN 表字段 varchar(50) DEFAULT NULL COMMENT &amp;apos;字段描述&amp;apos;;

表删除字段： ALTER TABLE 表名 DROP COLUMN  表字段 ;
      
    
    </summary>
    
      <category term="mysql" scheme="https://liuhusen.com/categories/mysql/"/>
    
    
      <category term="MySQL" scheme="https://liuhusen.com/tags/MySQL/"/>
    
      <category term="增删字段" scheme="https://liuhusen.com/tags/%E5%A2%9E%E5%88%A0%E5%AD%97%E6%AE%B5/"/>
    
      <category term="增删索引" scheme="https://liuhusen.com/tags/%E5%A2%9E%E5%88%A0%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的表以及数据备份</title>
    <link href="https://liuhusen.com/2017/05/26/MySQL%E7%9A%84%E8%A1%A8%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/"/>
    <id>https://liuhusen.com/2017/05/26/MySQL的表以及数据备份/</id>
    <published>2017-05-26T11:57:47.000Z</published>
    <updated>2018-10-28T19:14:11.519Z</updated>
    
    <content type="html"><![CDATA[<p>   备份表方法：  此方法索引和increment值也会同步</p><pre><code>CREATE TABLE tb_cab_bak LIKE tb_cab; // 同步建表INSERT INTO tb_cab_bak SELECT * FROM tb_cab；// 同步数据</code></pre><p>   若只复制表中的部分内容的同时定义表中的字段信息：<br>                 CREATE TABLE tb_cab_bak<br>                  (<br>                  – 对copy的表中的ID进行主键约束<br>                 ID INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY<br>                   )<br>                 AS<br>                 ( SELECT ID,SNAME,SCORE FROM tb_cab_bak );</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   备份表方法：  此方法索引和increment值也会同步&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE tb_cab_bak LIKE tb_cab; // 同步建表

INSERT INTO tb_cab_bak SELECT * FROM tb_cab；
      
    
    </summary>
    
      <category term="mysql" scheme="https://liuhusen.com/categories/mysql/"/>
    
    
      <category term="MySQL" scheme="https://liuhusen.com/tags/MySQL/"/>
    
      <category term="数据备份" scheme="https://liuhusen.com/tags/%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/"/>
    
  </entry>
  
  <entry>
    <title>自学编程成功概率有多少可能</title>
    <link href="https://liuhusen.com/2017/05/26/%E5%85%B3%E4%BA%8E/"/>
    <id>https://liuhusen.com/2017/05/26/关于/</id>
    <published>2017-05-26T11:57:47.000Z</published>
    <updated>2018-10-25T06:24:46.244Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="档案" scheme="https://liuhusen.com/categories/%E6%A1%A3%E6%A1%88/"/>
    
    
      <category term="编程" scheme="https://liuhusen.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="感悟" scheme="https://liuhusen.com/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>页面常用的设置：显示，隐藏，只读，不可编辑，取值，置空</title>
    <link href="https://liuhusen.com/2016/11/06/%E9%A1%B5%E9%9D%A2%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E7%BD%AE%EF%BC%9A%E6%98%BE%E7%A4%BA%EF%BC%8C%E9%9A%90%E8%97%8F%EF%BC%8C%E5%8F%AA%E8%AF%BB%EF%BC%8C%E4%B8%8D%E5%8F%AF%E7%BC%96%E8%BE%91%EF%BC%8C%E5%8F%96%E5%80%BC%EF%BC%8C%E7%BD%AE%E7%A9%BA/"/>
    <id>https://liuhusen.com/2016/11/06/页面常用的设置：显示，隐藏，只读，不可编辑，取值，置空/</id>
    <published>2016-11-06T04:28:30.000Z</published>
    <updated>2018-10-31T07:14:39.622Z</updated>
    
    <content type="html"><![CDATA[<pre><code>$(&quot;#id&quot;).val()   // 获取值$(&quot;#id&quot;).val(&apos;&apos;)   // 清空值$(&quot;#id&quot;).val(&apos;变量名&apos;)   // 赋值$(&quot;#id&quot;).css(&apos;display&apos;,&apos;block&apos;) // 显示选择的对象$(&quot;#id&quot;).css(&apos;display&apos;,&apos;none&apos;) // 隐藏选择的对象$(&quot;#msgIdTpl option[value=&apos;&quot;+msgIdTpl+&quot;&apos;]&quot;).attr(&quot;selected&quot;,true);  // 锁定下拉结果并是=使下拉不可编辑$(&quot;#id,#id2,#id3&quot;).attr(&quot;readonly&quot;,&quot;readonly&quot;); //多个选择设置只读属性$(&quot;#id,#id2).attr(&quot;disabled&quot;, true);  // 设置为不可用</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;$(&amp;quot;#id&amp;quot;).val()   // 获取值

$(&amp;quot;#id&amp;quot;).val(&amp;apos;&amp;apos;)   // 清空值

$(&amp;quot;#id&amp;quot;).val(&amp;apos;变量名&amp;apos;)   // 赋值
      
    
    </summary>
    
      <category term="javascript" scheme="https://liuhusen.com/categories/javascript/"/>
    
    
      <category term="javascript页面效果" scheme="https://liuhusen.com/tags/javascript%E9%A1%B5%E9%9D%A2%E6%95%88%E6%9E%9C/"/>
    
  </entry>
  
  <entry>
    <title>工作中重名判断的注意事项</title>
    <link href="https://liuhusen.com/2016/10/08/%E9%87%8D%E5%90%8D%E5%88%A4%E6%96%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://liuhusen.com/2016/10/08/重名判断的注意事项/</id>
    <published>2016-10-08T05:01:30.000Z</published>
    <updated>2018-10-31T06:31:07.533Z</updated>
    
    <content type="html"><![CDATA[<p>   工作中重名判断的注意事项：</p><p>   信息记录修改页面中重名判断如下：<br>          首先定义一个js中的全局变量stillName，用于存储要修改的信息原名；<br>          修改时判断 修改后名称是否 == 修改的信息原名，若等于则不进行重名判断，不然则反之；<br>          但是这里所有的 == 判断 以及  数据的保存，都应该是“去除数据两边空格后”的结果，<br>          否则，增减一个空格，判断结果也是不重名，而页面效果可看不到空格，给客户的视觉感受就是重名</p><p>   代码如下：<br>    var stillName = “需要更改的信息原名”</p><pre><code>if(stillName != $.trim(newName) ) {    // 此处是去数据库查找是否有信息含有  修改后名称}然后，在执行修改后数据保存的方法时传值注意：一定要也去掉空格  newName = $.trim(newName);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   工作中重名判断的注意事项：&lt;/p&gt;
&lt;p&gt;   信息记录修改页面中重名判断如下：&lt;br&gt;          首先定义一个js中的全局变量stillName，用于存储要修改的信息原名；&lt;br&gt;          修改时判断 修改后名称是否 == 修改的信息原名，若等于则
      
    
    </summary>
    
      <category term="javascript" scheme="https://liuhusen.com/categories/javascript/"/>
    
    
      <category term="javascript页面效果" scheme="https://liuhusen.com/tags/javascript%E9%A1%B5%E9%9D%A2%E6%95%88%E6%9E%9C/"/>
    
      <category term="重名判断" scheme="https://liuhusen.com/tags/%E9%87%8D%E5%90%8D%E5%88%A4%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>使用VMware安装CentOS 6.4</title>
    <link href="https://liuhusen.com/2016/08/16/%E4%BD%BF%E7%94%A8VMware%E5%AE%89%E8%A3%85CentOS-6-4/"/>
    <id>https://liuhusen.com/2016/08/16/使用VMware安装CentOS-6-4/</id>
    <published>2016-08-16T08:22:30.000Z</published>
    <updated>2018-11-01T05:58:16.393Z</updated>
    
    <content type="html"><![CDATA[<pre><code>环境：Windows7 , VMware Workstation10, CentOS6.4为什么选择CentOS ?1.主流： 目前的Linux操作系统主要应用于生产环境，主流企业级Linux系统仍旧是RedHat或者CentOS2.免费： RedHat 和CentOS差别不大，CentOS是一个基于Red Hat Linux 提供的可自由使用源代码的企业级Linux发行版本3.更新方便：CentOS独有的yum命令支持在线升级，可以即时更新系统，不像RED HAT那样需要花钱购买支持服务！安装步骤第1步：首先安装VMware Workstation，只需点下一步即可，安装过程略第2步：文件 → 新建虚拟机 或 直接点击 创建新的虚拟机 图标</code></pre><p><img src="/2016/08/16/使用VMware安装CentOS-6-4/01.png" alt="你想输入的替代文字"><br>    第3步：选择 典型（推荐）→ 下一步<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/02.png" alt="你想输入的替代文字"><br>    第4步：稍后安装操作系统<br><img src="/2016/08/16/使用VMware安装CentOS-6-4/03.png" alt="你想输入的替代文字"><br>    第5步：选择操作系统和版本<br><img src="/2016/08/16/使用VMware安装CentOS-6-4/04.png" alt="你想输入的替代文字"><br>    第6步：输入虚拟机名称和安装路径<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/05.png" alt="你想输入的替代文字"><br>    第7步：设置磁盘大小<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/06.png" alt="你想输入的替代文字"><br>    第8步：自定义硬件<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/07.png" alt="你想输入的替代文字"><br>    第9步：选择CentOS安装镜像文件<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/08.png" alt="你想输入的替代文字"><br>    第10步：点击完成<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/09.png" alt="你想输入的替代文字"><br>    第11步：启动虚拟机<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/10.png" alt="你想输入的替代文字"><br>    第12步：选择第一项，安装全新操作系统或升级现有操作系统<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/11.png" alt="你想输入的替代文字"><br>    第13步：Tab键进行选择，选择Skip，退出检测<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/12.png" alt="你想输入的替代文字"><br>    第14步：点击Next<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/13.png" alt="你想输入的替代文字"><br>    第15步：选择语言，这里选择的是中文简体<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/14.png" alt="你想输入的替代文字"><br>    第16步：选择键盘样式<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/15.png" alt="你想输入的替代文字"><br>    第17步：选择存储设备<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/16.png" alt="你想输入的替代文字"><br>     如果以前安装过虚拟机，会出现这个警告，选择是，忽略所有数据<br>     <img src="/2016/08/16/使用VMware安装CentOS-6-4/17.png" alt="你想输入的替代文字"><br>    第18步：输入主机名<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/18.png" alt="你想输入的替代文字"><br>    第19步：配置网络<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/19.png" alt="你想输入的替代文字"><br>    第20步：设置时区，勾选使用UTC时间<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/20.png" alt="你想输入的替代文字"><br>    第21步：输入根用户（root）的密码<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/21.png" alt="你想输入的替代文字"><br>      如果密码过于简单会出现提示，点击无论如何都使用<br>      <img src="/2016/08/16/使用VMware安装CentOS-6-4/22.png" alt="你想输入的替代文字"><br>    第22步：根据此Linux具体功能，选择不同的方式<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/23.png" alt="你想输入的替代文字"><br>    第23步：选择现在自定义，自定义安装需要的软件，如桌面配置<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/24.png" alt="你想输入的替代文字"><br>      可以根据具体的情况来配置，如可安Eclipse<br>      <img src="/2016/08/16/使用VMware安装CentOS-6-4/25.png" alt="你想输入的替代文字"><br>      还可以安装Java平台、Perl支持等<br>      <img src="/2016/08/16/使用VMware安装CentOS-6-4/26.png" alt="你想输入的替代文字"><br>      选择语言支持<br>      <img src="/2016/08/16/使用VMware安装CentOS-6-4/27.png" alt="你想输入的替代文字"><br>    第24步：点击下一步，开始安装<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/28.png" alt="你想输入的替代文字"><br>    第25步：安装完成后，点击重新导引<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/29.png" alt="你想输入的替代文字"><br>    第26步：点击前进按钮<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/30.png" alt="你想输入的替代文字"><br>    第27步：点击是，同意许可，再点击前进按钮<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/31.png" alt="你想输入的替代文字"><br>    第28步：创建用户<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/32.png" alt="你想输入的替代文字"><br>    第29步：设置日期和时间，如果可以上网，勾选在网上同步日期和时间<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/33.png" alt="你想输入的替代文字"><br>    最后点击前进，完成安装！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;环境：Windows7 , VMware Workstation10, CentOS6.4
为什么选择CentOS ?
1.主流： 目前的Linux操作系统主要应用于生产环境，主流企业级Linux系统仍旧是RedHat或者CentOS
2.免费： RedHa
      
    
    </summary>
    
      <category term="虚拟机VMware" scheme="https://liuhusen.com/categories/%E8%99%9A%E6%8B%9F%E6%9C%BAVMware/"/>
    
    
      <category term="虚拟机VMware安装教程" scheme="https://liuhusen.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BAVMware%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>关于FastDFS图片服务器详解</title>
    <link href="https://liuhusen.com/2016/08/16/%E5%85%B3%E4%BA%8EFastDFS%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>https://liuhusen.com/2016/08/16/关于FastDFS图片服务器详解/</id>
    <published>2016-08-16T08:22:30.000Z</published>
    <updated>2019-02-27T08:30:51.775Z</updated>
    
    <content type="html"><![CDATA[<pre><code>首先，什么是FastDFS ?    fastDFS是一款用C语言编写的开源的分布式文件系统，它就像是为互联网定制的，    因为它充分考虑到了 冗余备份、负载均衡、线性扩容等机制，并注重高可用、    高性能等指标。使用fastDFS很容易搭建一套高性能的文件服务器集群提供文件上传    和下载功能。fastDFS的架构：    fastDFS的架构包括tracker server 和 stroage server 。客户端请求 tracker server 进    行文件上传/下载，通过tracker server 调度最终由 stroage server 完成文件上传和下载        tracker server ：作用是负载均衡和调度，通过tracker server 在文件上传时通过一些策略    找到stroage server提供文件上传下载服务，可以称tracker server 为追踪服务器或调度服务器。    stroage server : 作用是文件存储，客户端上传的文件最终存储在 stroage 服务器上，stroage server没有    实现自己的文件系统而是利用操作系统的文件系统来管理文件，可称stroage server为存储服务器。    ![你想输入的替代文字](关于FastDFS图片服务器详解/01.png)服务端两个角色：    Tracker：管理集群，tracker也可以实现集群。每个tracker节点地位平等。    收集Storage集群的状态。    Storage：实际保存文件，Storage分为多个组，每个组之间保存的文件是不同的。    每个组内部可以有多个成员，组成员内部保存的内容是一样的，组成员的地位是一致的，没有主从的概念。文件上传的流程：    ![你想输入的替代文字](关于FastDFS图片服务器详解/02.png)客户端上传文件后存储服务器将文件ID返回给客户端，此文件ID用于以后访问该文件的索引信息。文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名。    ![你想输入的替代文字](关于FastDFS图片服务器详解/03.png)  组名：文件上传后所在的storage组名称，在文件上传成功后由storage服务器返回，          需要客户端自行保存。 </code></pre><p>      虚拟磁盘路径：storage配置的虚拟路径，与磁盘选项store_path*对应。如果配置<br>                      了store_path0则是M00，如果配置了store_path1则是M01，以此类推。<br>      数据两级目录：storage服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件。<br>      文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储服务器<br>                IP地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。</p><pre><code>文件下载：    ![你想输入的替代文字](关于FastDFS图片服务器详解/04.png)最简单的FastDFS架构：    ![你想输入的替代文字](关于FastDFS图片服务器详解/05.png)图片服务器安装方法：    1.安装步骤        第一步：把图片服务器解压缩。        第二步：把图片服务器添加到Vmware中。        第三步：Vmware的网络配置。        ![你想输入的替代文字](关于FastDFS图片服务器详解/06.png)        第四步：开机        ![你想输入的替代文字](关于FastDFS图片服务器详解/07.png)        移动：网络配置不发生变化。要使用图片服务器，需要保证网络配置不变。        复制：重新生成一块网卡mac地址是新地址。        Ip地址：192.168.25.133        用户名root、itcast        密码：itcast图片服务器使用：            ![你想输入的替代文字](关于FastDFS图片服务器详解/08.png)        ![你想输入的替代文字](关于FastDFS图片服务器详解/09.png)上传图片：    1.上传步骤：        1、加载配置文件，配置文件中的内容就是tracker服务的地址。           配置文件内容：tracker_server=192.168.25.133:22122        2、创建一个TrackerClient对象。直接new一个。        3、使用TrackerClient对象创建连接，获得一个TrackerServer对象。        4、创建一个StorageServer的引用，值为null        5、创建一个StorageClient对象，需要两个参数TrackerServer对象、StorageServer的引用        6、使用StorageClient对象上传图片。        7、返回数组。包含组名和图片的路径。        代码如下：        public class FastDFSTest {        @Test        public void testFileUpload() throws Exception {            // 1、加载配置文件，配置文件中的内容就是tracker服务的地址。            ClientGlobal.init(&quot;D:/workspaces-itcast/term197/taotao-manager-web/src/main/resources/resource/client.conf&quot;);            // 2、创建一个TrackerClient对象。直接new一个。            TrackerClient trackerClient = new TrackerClient();            // 3、使用TrackerClient对象创建连接，获得一个TrackerServer对象。            TrackerServer trackerServer = trackerClient.getConnection();            // 4、创建一个StorageServer的引用，值为null            StorageServer storageServer = null;            // 5、创建一个StorageClient对象，需要两个参数TrackerServer对象、StorageServer的引用            StorageClient storageClient = new StorageClient(trackerServer, storageServer);            // 6、使用StorageClient对象上传图片。            //扩展名不带“.”            String[] strings = storageClient.upload_file(&quot;D:/Documents/Pictures/images/200811281555127886.jpg&quot;, &quot;jpg&quot;, null);            // 7、返回数组。包含组名和图片的路径。            for (String string : strings) {                System.out.println(string);            }        }    }使用工具类上传：            ![你想输入的替代文字](关于FastDFS图片服务器详解/10.png)            @Test            public void testFastDfsClient() throws Exception {                FastDFSClient fastDFSClient = new FastDFSClient(&quot;D:/workspaces-itcast/term197/taotao-manager-web/src/main/resources/resource/client.conf&quot;);                String file = fastDFSClient.uploadFile(&quot;D:/Documents/Pictures/images/2f2eb938943d.jpg&quot;);                System.out.println(file);            }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;首先，什么是FastDFS ?
    fastDFS是一款用C语言编写的开源的分布式文件系统，它就像是为互联网定制的，
    因为它充分考虑到了 冗余备份、负载均衡、线性扩容等机制，并注重高可用、
    高性能等指标。使用fastDFS很容易搭建一套高
      
    
    </summary>
    
      <category term="服务器" scheme="https://liuhusen.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="FastDFS图片服务器" scheme="https://liuhusen.com/tags/FastDFS%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>基本的sql语句以及高级运算符和 多表查询</title>
    <link href="https://liuhusen.com/2016/07/20/%E5%9F%BA%E6%9C%AC%E7%9A%84sql%E8%AF%AD%E5%8F%A5%E4%BB%A5%E5%8F%8A%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%20%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
    <id>https://liuhusen.com/2016/07/20/基本的sql语句以及高级运算符和 多表查询/</id>
    <published>2016-07-20T11:57:47.000Z</published>
    <updated>2018-10-28T19:10:15.798Z</updated>
    
    <content type="html"><![CDATA[<p>选择：select * from table1 where Id=1(Id=1为条件语句，根据自己情况自定义）</p><p>插入：insert into table1(field1,field2) values(value1,value2)</p><p>删除：delete from table1 where 范围</p><p>更新：update table1 set field1=value1 where 范围</p><p>查找：select * from table1 where field1 like ’%value1%’ —like的语法很精妙，查资料!</p><p>排序：select * from table1 order by field1,field2 [desc]</p><p>总数：select count * as totalcount from table1</p><p>求和：select sum(field1) as sumvalue from table1</p><p>平均：select avg(field1) as avgvalue from table1</p><p>最大：select max(field1) as maxvalue from table1</p><p>最小：select min(field1) as minvalue from table1</p><p>11、说明：几个高级查询运算词</p><p>A： UNION 运算符</p><p>UNION 运算符通过组合其他两个结果表(例如 TABLE1 和 TABLE2)并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时(即 UNION ALL)，不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。</p><p>B： EXCEPT 运算符</p><p>EXCEPT 运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。</p><p>C： INTERSECT 运算符</p><p>INTERSECT 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。</p><p>注：使用运算词的几个查询结果行必须是一致的。</p><p>12、说明：使用外连接</p><p>A、left outer join：</p><p>左外连接(左连接)：结果集几包括连接表的匹配行，也包括左连接表的所有行。</p><p>SQL: select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c</p><p>B：right outer join:</p><p>右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。</p><p>C：full outer join：</p><p>全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;选择：select * from table1 where Id=1(Id=1为条件语句，根据自己情况自定义）&lt;/p&gt;
&lt;p&gt;插入：insert into table1(field1,field2) values(value1,value2)&lt;/p&gt;
&lt;p&gt;删除：delet
      
    
    </summary>
    
      <category term="mysql" scheme="https://liuhusen.com/categories/mysql/"/>
    
    
      <category term="SQL的各种基本操作" scheme="https://liuhusen.com/tags/SQL%E7%9A%84%E5%90%84%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    
      <category term="MySQL的高级运算符" scheme="https://liuhusen.com/tags/MySQL%E7%9A%84%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
      <category term="多表查询之左连接，右连接" scheme="https://liuhusen.com/tags/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E4%B9%8B%E5%B7%A6%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%8F%B3%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>MySQL建库建表建索引建视图建主键</title>
    <link href="https://liuhusen.com/2016/05/20/MySQL%E5%BB%BA%E5%BA%93%E5%BB%BA%E8%A1%A8%E5%BB%BA%E7%B4%A2%E5%BC%95%E5%BB%BA%E8%A7%86%E5%9B%BE%E5%BB%BA%E4%B8%BB%E9%94%AE/"/>
    <id>https://liuhusen.com/2016/05/20/MySQL建库建表建索引建视图建主键/</id>
    <published>2016-05-20T05:33:20.000Z</published>
    <updated>2018-10-28T19:13:06.070Z</updated>
    
    <content type="html"><![CDATA[<p>1、说明：创建数据库<br>CREATE DATABASE db1(db1代表数据库表，可自命名)<br>2、说明：删除数据库<br>drop database db1(db1代表数据库表，可自命名)<br>3、说明：备份sql server<br>— 创建 备份数据的 device<br>USE master<br>EXEC sp_addumpdevice ‘disk’, ‘testBack’, ‘c:\mssql7backup\MyNwind_1.dat’<br>— 开始 备份<br>BACKUP DATABASE pubs TO testBack<br>4、说明：创建新表<br>create table tb1(Id int not null primary key,name varchar,..)(tb1为数据表名，ID为字段，int为数据类型整型，not null为数据是否可为空，Primary Key为主键设置，其中not null,primary key为可选项，字段，数据类型自定义。）<br>根据已有的表创建新表：<br>A：create table tab_new like tab_old (使用旧表创建新表)<br>B：create table tab_new as select col1,col2… from tab_old definition only<br>5、说明：<br>删除新表：drop table tb1<br>6、说明：<br>添加主键：Alter table tabname add primary key(ID)(设置某字段为主键，ID可自由设置，主键数据不可重复）<br>说明：<br>删除主键：Alter table tabname drop primary key(ID)（删除某字段主键）<br>7、说明：<br>创建索引：create [unique] index idxname on tabname(col….)<br>删除索引：drop index idxname<br>注：索引是不可更改的，想更改必须删除重新建。<br>8、说明：<br>创建视图：create view viewname as select statement<br>删除视图：drop view viewname</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、说明：创建数据库&lt;br&gt;CREATE DATABASE db1(db1代表数据库表，可自命名)&lt;br&gt;2、说明：删除数据库&lt;br&gt;drop database db1(db1代表数据库表，可自命名)&lt;br&gt;3、说明：备份sql server&lt;br&gt;— 创建 备份数据的 d
      
    
    </summary>
    
      <category term="mysql" scheme="https://liuhusen.com/categories/mysql/"/>
    
    
      <category term="建库建表建索引建视图" scheme="https://liuhusen.com/tags/%E5%BB%BA%E5%BA%93%E5%BB%BA%E8%A1%A8%E5%BB%BA%E7%B4%A2%E5%BC%95%E5%BB%BA%E8%A7%86%E5%9B%BE/"/>
    
      <category term="备份数据库" scheme="https://liuhusen.com/tags/%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
