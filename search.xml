<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL的表增删字段和增删索引]]></title>
    <url>%2F2017%2F05%2F26%2FMySQL%E7%9A%84%E8%A1%A8%E5%A2%9E%E5%88%A0%E5%AD%97%E6%AE%B5%E5%92%8C%E5%A2%9E%E5%88%A0%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[表添加字段： ALTER TABLE 表名 ADD COLUMN 表字段 varchar(50) DEFAULT NULL COMMENT &apos;字段描述&apos;; 表删除字段： ALTER TABLE 表名 DROP COLUMN 表字段 ; 字段建唯一索引：create index idx_province_id on 表名 (表字段 ); 上为索引 create index 字段的索引 on 表名 (表字段 ); 删除字段的索引：alter table 表名 drop index idx_province_id ; 上为索引 alter table 表名 drop 字段的索引 ;]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>增删字段</tag>
        <tag>增删索引</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的表以及数据备份]]></title>
    <url>%2F2017%2F05%2F26%2FMySQL%E7%9A%84%E8%A1%A8%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[备份表方法： 此方法索引和increment值也会同步 CREATE TABLE tb_cab_bak LIKE tb_cab; // 同步建表 INSERT INTO tb_cab_bak SELECT * FROM tb_cab；// 同步数据 若只复制表中的部分内容的同时定义表中的字段信息： CREATE TABLE tb_cab_bak ( – 对copy的表中的ID进行主键约束 ID INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY ) AS ( SELECT ID,SNAME,SCORE FROM tb_cab_bak );]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据备份</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自学编程成功概率有多少可能]]></title>
    <url>%2F2017%2F05%2F26%2F%E5%85%B3%E4%BA%8E%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>档案</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本的sql语句以及高级运算符和 多表查询]]></title>
    <url>%2F2016%2F07%2F20%2F%E5%9F%BA%E6%9C%AC%E7%9A%84sql%E8%AF%AD%E5%8F%A5%E4%BB%A5%E5%8F%8A%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%20%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[选择：select * from table1 where Id=1(Id=1为条件语句，根据自己情况自定义） 插入：insert into table1(field1,field2) values(value1,value2) 删除：delete from table1 where 范围 更新：update table1 set field1=value1 where 范围 查找：select * from table1 where field1 like ’%value1%’ —like的语法很精妙，查资料! 排序：select * from table1 order by field1,field2 [desc] 总数：select count * as totalcount from table1 求和：select sum(field1) as sumvalue from table1 平均：select avg(field1) as avgvalue from table1 最大：select max(field1) as maxvalue from table1 最小：select min(field1) as minvalue from table1 11、说明：几个高级查询运算词 A： UNION 运算符 UNION 运算符通过组合其他两个结果表(例如 TABLE1 和 TABLE2)并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时(即 UNION ALL)，不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。 B： EXCEPT 运算符 EXCEPT 运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。 C： INTERSECT 运算符 INTERSECT 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。 注：使用运算词的几个查询结果行必须是一致的。 12、说明：使用外连接 A、left outer join： 左外连接(左连接)：结果集几包括连接表的匹配行，也包括左连接表的所有行。 SQL: select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c B：right outer join: 右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。 C：full outer join： 全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>SQL的各种基本操作</tag>
        <tag>MySQL的高级运算符</tag>
        <tag>多表查询之左连接，右连接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL建库建表建索引建视图建主键]]></title>
    <url>%2F2016%2F05%2F20%2FMySQL%E5%BB%BA%E5%BA%93%E5%BB%BA%E8%A1%A8%E5%BB%BA%E7%B4%A2%E5%BC%95%E5%BB%BA%E8%A7%86%E5%9B%BE%E5%BB%BA%E4%B8%BB%E9%94%AE%2F</url>
    <content type="text"><![CDATA[1、说明：创建数据库CREATE DATABASE db1(db1代表数据库表，可自命名)2、说明：删除数据库drop database db1(db1代表数据库表，可自命名)3、说明：备份sql server— 创建 备份数据的 deviceUSE masterEXEC sp_addumpdevice ‘disk’, ‘testBack’, ‘c:\mssql7backup\MyNwind_1.dat’— 开始 备份BACKUP DATABASE pubs TO testBack4、说明：创建新表create table tb1(Id int not null primary key,name varchar,..)(tb1为数据表名，ID为字段，int为数据类型整型，not null为数据是否可为空，Primary Key为主键设置，其中not null,primary key为可选项，字段，数据类型自定义。）根据已有的表创建新表：A：create table tab_new like tab_old (使用旧表创建新表)B：create table tab_new as select col1,col2… from tab_old definition only5、说明：删除新表：drop table tb16、说明：添加主键：Alter table tabname add primary key(ID)(设置某字段为主键，ID可自由设置，主键数据不可重复）说明：删除主键：Alter table tabname drop primary key(ID)（删除某字段主键）7、说明：创建索引：create [unique] index idxname on tabname(col….)删除索引：drop index idxname注：索引是不可更改的，想更改必须删除重新建。8、说明：创建视图：create view viewname as select statement删除视图：drop view viewname]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>建库建表建索引建视图</tag>
        <tag>备份数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql进行大数据量查询的性能优化]]></title>
    <url>%2F2016%2F03%2F26%2FMysql%E8%BF%9B%E8%A1%8C%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[数据库设计方面： 1、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 2、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。 如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0 3、并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时,查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半， 那么即使在sex上建了索引也对查询效率起不了作用。 4、索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重 考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。 5、应尽可能的避免更新索引数据列，因为索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频 繁更新索引数据列，那么需要考虑是否应将该索引建为索引。 6、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每 一个字符，而对于数字型而言只需要比较一次就够了。 7、尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 8、避免频繁创建和删除临时表，以减少系统表资源的消耗。 9、临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。 10、在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先 create table，然后insert。 11、如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 SQL语句方面： 1、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。 2、应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描 如： select id from t where num=10 or num=20 可以这样查询： select id from t where num=10 union all select id from t where num=20 3、in 和 not in 也要慎用，否则会导致全表扫描。 如： select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and 3 4、下面的查询也将导致全表扫描： select id from t where name like ‘%abc%’ 5、如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。 然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。 如下面语句将进行全表扫描： select id from t where num=@num 可以改为强制查询使用索引： select id from t with(index(索引名)) where num=@num 6、应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。 如： select id from t where num/2=100 应改为: select id from t where num=100*2 7、应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。 如： select id from t where substring(name,1,3)=’abc’ ——name以abc开头的id select id from t where datediff(day,createdate,’2005-11-30′)=0 ——‘2005-11-30’生成的id 应改为： select id from t where name like ‘abc%’ select id from t where createdate&gt;=’2005-11-30′ and createdate&lt;’2005-12-1′ 8、不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 9、不要写一些没有意义的查询，如需要生成一个空表结构： select col1,col2 into #t from t where 1=0 这类代码不会返回任何结果集，但是会消耗系统资源的， 应改成这样： create table #t(„) 10、很多时候用 exists 代替 in 是一个好的选择： select num from a where num in(select num from b) 用下面的语句替换： select num from a where exists(select 1 from b where num=a.num) 11、任何地方都不要使用 select from t ，用具体的字段列表代替“”，不要返回用不到的任何字段。 12、尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。 13、尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 14、尽量避免大事务操作，提高系统并发能力。 java方面： 1、尽可能的少造对象。 2、合理摆正系统设计的位置。大量数据操作，和少量数据操作一定是分开的。大量的数据操作，肯定不是ORM框架搞定的。 3、使用jDBC链接数据库操作数据。 4、控制好内存，让数据流起来，而不是全部读到内存再处理，而是边读取边处理。 5、合理利用内存，有的数据要缓存]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>大数据量查询</tag>
        <tag>查询优化</tag>
        <tag>sql语句优化</tag>
      </tags>
  </entry>
</search>
